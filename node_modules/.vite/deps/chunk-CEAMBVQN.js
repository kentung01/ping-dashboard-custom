import {
  require_ripemd160,
  require_sha256,
  require_sha512
} from "./chunk-D6Z6QF6Q.js";
import {
  __commonJS
} from "./chunk-2GTGKKMZ.js";

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer = util.inquire("buffer").Buffer;
        return Buffer.prototype.utf8Write ? Buffer : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer = util.Buffer;
      if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/@confio/ics23/build/generated/codecimpl.js
var require_codecimpl = __commonJS({
  "node_modules/@confio/ics23/build/generated/codecimpl.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.ics23 = function() {
      var ics23 = {};
      ics23.HashOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_HASH"] = 0;
        values[valuesById[1] = "SHA256"] = 1;
        values[valuesById[2] = "SHA512"] = 2;
        values[valuesById[3] = "KECCAK"] = 3;
        values[valuesById[4] = "RIPEMD160"] = 4;
        values[valuesById[5] = "BITCOIN"] = 5;
        values[valuesById[6] = "SHA512_256"] = 6;
        return values;
      }();
      ics23.LengthOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_PREFIX"] = 0;
        values[valuesById[1] = "VAR_PROTO"] = 1;
        values[valuesById[2] = "VAR_RLP"] = 2;
        values[valuesById[3] = "FIXED32_BIG"] = 3;
        values[valuesById[4] = "FIXED32_LITTLE"] = 4;
        values[valuesById[5] = "FIXED64_BIG"] = 5;
        values[valuesById[6] = "FIXED64_LITTLE"] = 6;
        values[valuesById[7] = "REQUIRE_32_BYTES"] = 7;
        values[valuesById[8] = "REQUIRE_64_BYTES"] = 8;
        return values;
      }();
      ics23.ExistenceProof = function() {
        function ExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ExistenceProof.prototype.key = $util.newBuffer([]);
        ExistenceProof.prototype.value = $util.newBuffer([]);
        ExistenceProof.prototype.leaf = null;
        ExistenceProof.prototype.path = $util.emptyArray;
        ExistenceProof.create = function create(properties) {
          return new ExistenceProof(properties);
        };
        ExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length)
            for (var i = 0; i < message.path.length; ++i)
              $root.ics23.InnerOp.encode(message.path[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
          return writer;
        };
        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.path[i]);
              if (error)
                return "path." + error;
            }
          }
          return null;
        };
        ExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ExistenceProof)
            return object;
          var message = new $root.ics23.ExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.ExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.ExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i) {
              if (typeof object.path[i] !== "object")
                throw TypeError(".ics23.ExistenceProof.path: object expected");
              message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);
            }
          }
          return message;
        };
        ExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);
          }
          return object;
        };
        ExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExistenceProof;
      }();
      ics23.NonExistenceProof = function() {
        function NonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        NonExistenceProof.prototype.key = $util.newBuffer([]);
        NonExistenceProof.prototype.left = null;
        NonExistenceProof.prototype.right = null;
        NonExistenceProof.create = function create(properties) {
          return new NonExistenceProof(properties);
        };
        NonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.ExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.ExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        NonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.ExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.ExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        NonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.NonExistenceProof)
            return object;
          var message = new $root.ics23.NonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.NonExistenceProof.left: object expected");
            message.left = $root.ics23.ExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.NonExistenceProof.right: object expected");
            message.right = $root.ics23.ExistenceProof.fromObject(object.right);
          }
          return message;
        };
        NonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.ExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.ExistenceProof.toObject(message.right, options);
          return object;
        };
        NonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return NonExistenceProof;
      }();
      ics23.CommitmentProof = function() {
        function CommitmentProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CommitmentProof.prototype.exist = null;
        CommitmentProof.prototype.nonexist = null;
        CommitmentProof.prototype.batch = null;
        CommitmentProof.prototype.compressed = null;
        var $oneOfFields;
        Object.defineProperty(CommitmentProof.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist", "batch", "compressed"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CommitmentProof.create = function create(properties) {
          return new CommitmentProof(properties);
        };
        CommitmentProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.batch != null && message.hasOwnProperty("batch"))
            $root.ics23.BatchProof.encode(message.batch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.compressed != null && message.hasOwnProperty("compressed"))
            $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          return writer;
        };
        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CommitmentProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());
                break;
              case 4:
                message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CommitmentProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.BatchProof.verify(message.batch);
              if (error)
                return "batch." + error;
            }
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedBatchProof.verify(message.compressed);
              if (error)
                return "compressed." + error;
            }
          }
          return null;
        };
        CommitmentProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CommitmentProof)
            return object;
          var message = new $root.ics23.CommitmentProof();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CommitmentProof.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          if (object.batch != null) {
            if (typeof object.batch !== "object")
              throw TypeError(".ics23.CommitmentProof.batch: object expected");
            message.batch = $root.ics23.BatchProof.fromObject(object.batch);
          }
          if (object.compressed != null) {
            if (typeof object.compressed !== "object")
              throw TypeError(".ics23.CommitmentProof.compressed: object expected");
            message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);
          }
          return message;
        };
        CommitmentProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            object.batch = $root.ics23.BatchProof.toObject(message.batch, options);
            if (options.oneofs)
              object.proof = "batch";
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);
            if (options.oneofs)
              object.proof = "compressed";
          }
          return object;
        };
        CommitmentProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CommitmentProof;
      }();
      ics23.LeafOp = function() {
        function LeafOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        LeafOp.prototype.hash = 0;
        LeafOp.prototype.prehashKey = 0;
        LeafOp.prototype.prehashValue = 0;
        LeafOp.prototype.length = 0;
        LeafOp.prototype.prefix = $util.newBuffer([]);
        LeafOp.create = function create(properties) {
          return new LeafOp(properties);
        };
        LeafOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.prehashKey);
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.prehashValue);
          if (message.length != null && message.hasOwnProperty("length"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.length);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.prefix);
          return writer;
        };
        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        LeafOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prehashKey = reader.int32();
                break;
              case 3:
                message.prehashValue = reader.int32();
                break;
              case 4:
                message.length = reader.int32();
                break;
              case 5:
                message.prefix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        LeafOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        LeafOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            switch (message.prehashKey) {
              default:
                return "prehashKey: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            switch (message.prehashValue) {
              default:
                return "prehashValue: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.length != null && message.hasOwnProperty("length"))
            switch (message.length) {
              default:
                return "length: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          return null;
        };
        LeafOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.LeafOp)
            return object;
          var message = new $root.ics23.LeafOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          switch (object.prehashKey) {
            case "NO_HASH":
            case 0:
              message.prehashKey = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashKey = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashKey = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashKey = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashKey = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashKey = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashKey = 6;
              break;
          }
          switch (object.prehashValue) {
            case "NO_HASH":
            case 0:
              message.prehashValue = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashValue = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashValue = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashValue = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashValue = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashValue = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashValue = 6;
              break;
          }
          switch (object.length) {
            case "NO_PREFIX":
            case 0:
              message.length = 0;
              break;
            case "VAR_PROTO":
            case 1:
              message.length = 1;
              break;
            case "VAR_RLP":
            case 2:
              message.length = 2;
              break;
            case "FIXED32_BIG":
            case 3:
              message.length = 3;
              break;
            case "FIXED32_LITTLE":
            case 4:
              message.length = 4;
              break;
            case "FIXED64_BIG":
            case 5:
              message.length = 5;
              break;
            case "FIXED64_LITTLE":
            case 6:
              message.length = 6;
              break;
            case "REQUIRE_32_BYTES":
            case 7:
              message.length = 7;
              break;
            case "REQUIRE_64_BYTES":
            case 8:
              message.length = 8;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          return message;
        };
        LeafOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            object.prehashKey = options.enums === String ? "NO_HASH" : 0;
            object.prehashValue = options.enums === String ? "NO_HASH" : 0;
            object.length = options.enums === String ? "NO_PREFIX" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;
          if (message.length != null && message.hasOwnProperty("length"))
            object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          return object;
        };
        LeafOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return LeafOp;
      }();
      ics23.InnerOp = function() {
        function InnerOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerOp.prototype.hash = 0;
        InnerOp.prototype.prefix = $util.newBuffer([]);
        InnerOp.prototype.suffix = $util.newBuffer([]);
        InnerOp.create = function create(properties) {
          return new InnerOp(properties);
        };
        InnerOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.prefix);
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.suffix);
          return writer;
        };
        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prefix = reader.bytes();
                break;
              case 3:
                message.suffix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          if (message.suffix != null && message.hasOwnProperty("suffix")) {
            if (!(message.suffix && typeof message.suffix.length === "number" || $util.isString(message.suffix)))
              return "suffix: buffer expected";
          }
          return null;
        };
        InnerOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerOp)
            return object;
          var message = new $root.ics23.InnerOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          if (object.suffix != null) {
            if (typeof object.suffix === "string")
              $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);
            else if (object.suffix.length)
              message.suffix = object.suffix;
          }
          return message;
        };
        InnerOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
            if (options.bytes === String)
              object.suffix = "";
            else {
              object.suffix = [];
              if (options.bytes !== Array)
                object.suffix = $util.newBuffer(object.suffix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;
          return object;
        };
        InnerOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerOp;
      }();
      ics23.ProofSpec = function() {
        function ProofSpec(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ProofSpec.prototype.leafSpec = null;
        ProofSpec.prototype.innerSpec = null;
        ProofSpec.prototype.maxDepth = 0;
        ProofSpec.prototype.minDepth = 0;
        ProofSpec.create = function create(properties) {
          return new ProofSpec(properties);
        };
        ProofSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.maxDepth);
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.minDepth);
          return writer;
        };
        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ProofSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 2:
                message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());
                break;
              case 3:
                message.maxDepth = reader.int32();
                break;
              case 4:
                message.minDepth = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ProofSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ProofSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec")) {
            var error = $root.ics23.LeafOp.verify(message.leafSpec);
            if (error)
              return "leafSpec." + error;
          }
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec")) {
            var error = $root.ics23.InnerSpec.verify(message.innerSpec);
            if (error)
              return "innerSpec." + error;
          }
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth")) {
            if (!$util.isInteger(message.maxDepth))
              return "maxDepth: integer expected";
          }
          if (message.minDepth != null && message.hasOwnProperty("minDepth")) {
            if (!$util.isInteger(message.minDepth))
              return "minDepth: integer expected";
          }
          return null;
        };
        ProofSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ProofSpec)
            return object;
          var message = new $root.ics23.ProofSpec();
          if (object.leafSpec != null) {
            if (typeof object.leafSpec !== "object")
              throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
            message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);
          }
          if (object.innerSpec != null) {
            if (typeof object.innerSpec !== "object")
              throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
            message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);
          }
          if (object.maxDepth != null)
            message.maxDepth = object.maxDepth | 0;
          if (object.minDepth != null)
            message.minDepth = object.minDepth | 0;
          return message;
        };
        ProofSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.leafSpec = null;
            object.innerSpec = null;
            object.maxDepth = 0;
            object.minDepth = 0;
          }
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            object.maxDepth = message.maxDepth;
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            object.minDepth = message.minDepth;
          return object;
        };
        ProofSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProofSpec;
      }();
      ics23.InnerSpec = function() {
        function InnerSpec(properties) {
          this.childOrder = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerSpec.prototype.childOrder = $util.emptyArray;
        InnerSpec.prototype.childSize = 0;
        InnerSpec.prototype.minPrefixLength = 0;
        InnerSpec.prototype.maxPrefixLength = 0;
        InnerSpec.prototype.emptyChild = $util.newBuffer([]);
        InnerSpec.prototype.hash = 0;
        InnerSpec.create = function create(properties) {
          return new InnerSpec(properties);
        };
        InnerSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.childOrder != null && message.childOrder.length) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork();
            for (var i = 0; i < message.childOrder.length; ++i)
              writer.int32(message.childOrder[i]);
            writer.ldelim();
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.childSize);
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.minPrefixLength);
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.maxPrefixLength);
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.emptyChild);
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).int32(message.hash);
          return writer;
        };
        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.childOrder && message.childOrder.length))
                  message.childOrder = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.childOrder.push(reader.int32());
                } else
                  message.childOrder.push(reader.int32());
                break;
              case 2:
                message.childSize = reader.int32();
                break;
              case 3:
                message.minPrefixLength = reader.int32();
                break;
              case 4:
                message.maxPrefixLength = reader.int32();
                break;
              case 5:
                message.emptyChild = reader.bytes();
                break;
              case 6:
                message.hash = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.childOrder != null && message.hasOwnProperty("childOrder")) {
            if (!Array.isArray(message.childOrder))
              return "childOrder: array expected";
            for (var i = 0; i < message.childOrder.length; ++i)
              if (!$util.isInteger(message.childOrder[i]))
                return "childOrder: integer[] expected";
          }
          if (message.childSize != null && message.hasOwnProperty("childSize")) {
            if (!$util.isInteger(message.childSize))
              return "childSize: integer expected";
          }
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength")) {
            if (!$util.isInteger(message.minPrefixLength))
              return "minPrefixLength: integer expected";
          }
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength")) {
            if (!$util.isInteger(message.maxPrefixLength))
              return "maxPrefixLength: integer expected";
          }
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild")) {
            if (!(message.emptyChild && typeof message.emptyChild.length === "number" || $util.isString(message.emptyChild)))
              return "emptyChild: buffer expected";
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          return null;
        };
        InnerSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerSpec)
            return object;
          var message = new $root.ics23.InnerSpec();
          if (object.childOrder) {
            if (!Array.isArray(object.childOrder))
              throw TypeError(".ics23.InnerSpec.childOrder: array expected");
            message.childOrder = [];
            for (var i = 0; i < object.childOrder.length; ++i)
              message.childOrder[i] = object.childOrder[i] | 0;
          }
          if (object.childSize != null)
            message.childSize = object.childSize | 0;
          if (object.minPrefixLength != null)
            message.minPrefixLength = object.minPrefixLength | 0;
          if (object.maxPrefixLength != null)
            message.maxPrefixLength = object.maxPrefixLength | 0;
          if (object.emptyChild != null) {
            if (typeof object.emptyChild === "string")
              $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);
            else if (object.emptyChild.length)
              message.emptyChild = object.emptyChild;
          }
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          return message;
        };
        InnerSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.childOrder = [];
          if (options.defaults) {
            object.childSize = 0;
            object.minPrefixLength = 0;
            object.maxPrefixLength = 0;
            if (options.bytes === String)
              object.emptyChild = "";
            else {
              object.emptyChild = [];
              if (options.bytes !== Array)
                object.emptyChild = $util.newBuffer(object.emptyChild);
            }
            object.hash = options.enums === String ? "NO_HASH" : 0;
          }
          if (message.childOrder && message.childOrder.length) {
            object.childOrder = [];
            for (var j = 0; j < message.childOrder.length; ++j)
              object.childOrder[j] = message.childOrder[j];
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            object.childSize = message.childSize;
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            object.minPrefixLength = message.minPrefixLength;
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            object.maxPrefixLength = message.maxPrefixLength;
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          return object;
        };
        InnerSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerSpec;
      }();
      ics23.BatchProof = function() {
        function BatchProof(properties) {
          this.entries = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchProof.prototype.entries = $util.emptyArray;
        BatchProof.create = function create(properties) {
          return new BatchProof(properties);
        };
        BatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.BatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          return null;
        };
        BatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchProof)
            return object;
          var message = new $root.ics23.BatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.BatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.BatchProof.entries: object expected");
              message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);
            }
          }
          return message;
        };
        BatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.entries = [];
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);
          }
          return object;
        };
        BatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchProof;
      }();
      ics23.BatchEntry = function() {
        function BatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchEntry.prototype.exist = null;
        BatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(BatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        BatchEntry.create = function create(properties) {
          return new BatchEntry(properties);
        };
        BatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        BatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchEntry)
            return object;
          var message = new $root.ics23.BatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.BatchEntry.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.BatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        BatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        BatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchEntry;
      }();
      ics23.CompressedBatchProof = function() {
        function CompressedBatchProof(properties) {
          this.entries = [];
          this.lookupInners = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchProof.prototype.entries = $util.emptyArray;
        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;
        CompressedBatchProof.create = function create(properties) {
          return new CompressedBatchProof(properties);
        };
        CompressedBatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          if (message.lookupInners != null && message.lookupInners.length)
            for (var i = 0; i < message.lookupInners.length; ++i)
              $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          return writer;
        };
        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));
                break;
              case 2:
                if (!(message.lookupInners && message.lookupInners.length))
                  message.lookupInners = [];
                message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          if (message.lookupInners != null && message.hasOwnProperty("lookupInners")) {
            if (!Array.isArray(message.lookupInners))
              return "lookupInners: array expected";
            for (var i = 0; i < message.lookupInners.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);
              if (error)
                return "lookupInners." + error;
            }
          }
          return null;
        };
        CompressedBatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchProof)
            return object;
          var message = new $root.ics23.CompressedBatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
              message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);
            }
          }
          if (object.lookupInners) {
            if (!Array.isArray(object.lookupInners))
              throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
            message.lookupInners = [];
            for (var i = 0; i < object.lookupInners.length; ++i) {
              if (typeof object.lookupInners[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
              message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);
            }
          }
          return message;
        };
        CompressedBatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.entries = [];
            object.lookupInners = [];
          }
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);
          }
          if (message.lookupInners && message.lookupInners.length) {
            object.lookupInners = [];
            for (var j = 0; j < message.lookupInners.length; ++j)
              object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);
          }
          return object;
        };
        CompressedBatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchProof;
      }();
      ics23.CompressedBatchEntry = function() {
        function CompressedBatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchEntry.prototype.exist = null;
        CompressedBatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(CompressedBatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CompressedBatchEntry.create = function create(properties) {
          return new CompressedBatchEntry(properties);
        };
        CompressedBatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        CompressedBatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchEntry)
            return object;
          var message = new $root.ics23.CompressedBatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
            message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        CompressedBatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        CompressedBatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchEntry;
      }();
      ics23.CompressedExistenceProof = function() {
        function CompressedExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedExistenceProof.prototype.value = $util.newBuffer([]);
        CompressedExistenceProof.prototype.leaf = null;
        CompressedExistenceProof.prototype.path = $util.emptyArray;
        CompressedExistenceProof.create = function create(properties) {
          return new CompressedExistenceProof(properties);
        };
        CompressedExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork();
            for (var i = 0; i < message.path.length; ++i)
              writer.int32(message.path[i]);
            writer.ldelim();
          }
          return writer;
        };
        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.path.push(reader.int32());
                } else
                  message.path.push(reader.int32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i)
              if (!$util.isInteger(message.path[i]))
                return "path: integer[] expected";
          }
          return null;
        };
        CompressedExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedExistenceProof)
            return object;
          var message = new $root.ics23.CompressedExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i)
              message.path[i] = object.path[i] | 0;
          }
          return message;
        };
        CompressedExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = message.path[j];
          }
          return object;
        };
        CompressedExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedExistenceProof;
      }();
      ics23.CompressedNonExistenceProof = function() {
        function CompressedNonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedNonExistenceProof.prototype.left = null;
        CompressedNonExistenceProof.prototype.right = null;
        CompressedNonExistenceProof.create = function create(properties) {
          return new CompressedNonExistenceProof(properties);
        };
        CompressedNonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedNonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedNonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        CompressedNonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedNonExistenceProof)
            return object;
          var message = new $root.ics23.CompressedNonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
            message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
            message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);
          }
          return message;
        };
        CompressedNonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);
          return object;
        };
        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedNonExistenceProof;
      }();
      return ics23;
    }();
    module2.exports = $root;
  }
});

// node_modules/@confio/ics23/build/compress.js
var require_compress = __commonJS({
  "node_modules/@confio/ics23/build/compress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompress = exports2.compress = void 0;
    var codecimpl_1 = require_codecimpl();
    function compress(proof) {
      if (!proof.batch) {
        return proof;
      }
      return { compressed: compressBatch(proof.batch) };
    }
    exports2.compress = compress;
    function decompress(proof) {
      if (!proof.compressed) {
        return proof;
      }
      return { batch: decompressBatch(proof.compressed) };
    }
    exports2.decompress = decompress;
    function compressBatch(proof) {
      const centries = [];
      const lookup = [];
      const registry = /* @__PURE__ */ new Map();
      for (const entry of proof.entries) {
        if (entry.exist) {
          const centry = { exist: compressExist(entry.exist, lookup, registry) };
          centries.push(centry);
        } else if (entry.nonexist) {
          const non = entry.nonexist;
          const centry = {
            nonexist: {
              key: non.key,
              left: compressExist(non.left, lookup, registry),
              right: compressExist(non.right, lookup, registry)
            }
          };
          centries.push(centry);
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      }
      return {
        entries: centries,
        lookupInners: lookup
      };
    }
    function compressExist(exist, lookup, registry) {
      if (!exist) {
        return void 0;
      }
      const path = exist.path.map((inner) => {
        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();
        let idx = registry.get(sig);
        if (idx === void 0) {
          idx = lookup.length;
          lookup.push(inner);
          registry.set(sig, idx);
        }
        return idx;
      });
      return {
        key: exist.key,
        value: exist.value,
        leaf: exist.leaf,
        path
      };
    }
    function decompressBatch(proof) {
      const lookup = proof.lookupInners;
      const entries = proof.entries.map((comp) => {
        if (comp.exist) {
          return { exist: decompressExist(comp.exist, lookup) };
        } else if (comp.nonexist) {
          const non = comp.nonexist;
          return {
            nonexist: {
              key: non.key,
              left: decompressExist(non.left, lookup),
              right: decompressExist(non.right, lookup)
            }
          };
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      });
      return {
        entries
      };
    }
    function decompressExist(exist, lookup) {
      if (!exist) {
        return void 0;
      }
      const { key, value, leaf, path } = exist;
      const newPath = (path || []).map((idx) => lookup[idx]);
      return { key, value, leaf, path: newPath };
    }
  }
});

// node_modules/@confio/ics23/build/ops.js
var require_ops = __commonJS({
  "node_modules/@confio/ics23/build/ops.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.doHash = exports2.applyInner = exports2.applyLeaf = void 0;
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var codecimpl_1 = require_codecimpl();
    function applyLeaf(leaf, key, value) {
      if (key.length === 0) {
        throw new Error("Missing key");
      }
      if (value.length === 0) {
        throw new Error("Missing value");
      }
      const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);
      const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);
      const data = new Uint8Array([
        ...ensureBytes(leaf.prefix),
        ...pkey,
        ...pvalue
      ]);
      return doHash(ensureHash(leaf.hash), data);
    }
    exports2.applyLeaf = applyLeaf;
    function applyInner(inner, child) {
      if (child.length === 0) {
        throw new Error("Inner op needs child value");
      }
      const preimage = new Uint8Array([
        ...ensureBytes(inner.prefix),
        ...child,
        ...ensureBytes(inner.suffix)
      ]);
      return doHash(ensureHash(inner.hash), preimage);
    }
    exports2.applyInner = applyInner;
    function ensure(maybe, value) {
      return maybe === void 0 || maybe === null ? value : maybe;
    }
    var ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);
    var ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);
    var ensureBytes = (b) => ensure(b, new Uint8Array([]));
    function prepareLeafData(hashOp, lengthOp, data) {
      const h = doHashOrNoop(hashOp, data);
      return doLengthOp(lengthOp, h);
    }
    function doHashOrNoop(hashOp, preimage) {
      if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {
        return preimage;
      }
      return doHash(hashOp, preimage);
    }
    function doHash(hashOp, preimage) {
      switch (hashOp) {
        case codecimpl_1.ics23.HashOp.SHA256:
          return (0, sha256_1.sha256)(preimage);
        case codecimpl_1.ics23.HashOp.SHA512:
          return (0, sha512_1.sha512)(preimage);
        case codecimpl_1.ics23.HashOp.RIPEMD160:
          return (0, ripemd160_1.ripemd160)(preimage);
        case codecimpl_1.ics23.HashOp.BITCOIN:
          return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));
        case codecimpl_1.ics23.HashOp.SHA512_256:
          return (0, sha512_1.sha512_256)(preimage);
      }
      throw new Error(`Unsupported hashop: ${hashOp}`);
    }
    exports2.doHash = doHash;
    function doLengthOp(lengthOp, data) {
      switch (lengthOp) {
        case codecimpl_1.ics23.LengthOp.NO_PREFIX:
          return data;
        case codecimpl_1.ics23.LengthOp.VAR_PROTO:
          return new Uint8Array([...encodeVarintProto(data.length), ...data]);
        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:
          if (data.length !== 32) {
            throw new Error(`Length is ${data.length}, not 32 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:
          if (data.length !== 64) {
            throw new Error(`Length is ${data.length}, not 64 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:
          return new Uint8Array([...encodeFixed32Le(data.length), ...data]);
      }
      throw new Error(`Unsupported lengthop: ${lengthOp}`);
    }
    function encodeVarintProto(n) {
      let enc = [];
      let l = n;
      while (l >= 128) {
        const b = l % 128 + 128;
        enc = [...enc, b];
        l = l / 128;
      }
      enc = [...enc, l];
      return new Uint8Array(enc);
    }
    function encodeFixed32Le(n) {
      const enc = new Uint8Array(4);
      let l = n;
      for (let i = enc.length; i > 0; i--) {
        enc[Math.abs(i - enc.length)] = l % 256;
        l = Math.floor(l / 256);
      }
      return enc;
    }
  }
});

// node_modules/@confio/ics23/build/specs.js
var require_specs = __commonJS({
  "node_modules/@confio/ics23/build/specs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytesBefore = exports2.ensureBytesBefore = exports2.bytesEqual = exports2.ensureBytesEqual = exports2.ensureInner = exports2.ensureLeaf = void 0;
    function ensureLeaf(leaf, spec) {
      if (leaf.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${leaf.hash}`);
      }
      if (leaf.prehashKey !== spec.prehashKey) {
        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);
      }
      if (leaf.prehashValue !== spec.prehashValue) {
        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);
      }
      if (leaf.length !== spec.length) {
        throw new Error(`Unexpected length op: ${leaf.length}`);
      }
      ensurePrefix(leaf.prefix, spec.prefix);
    }
    exports2.ensureLeaf = ensureLeaf;
    function ensureInner(inner, prefix, spec) {
      if (inner.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${inner.hash}`);
      }
      if (!inner.prefix) {
        throw new Error("No prefix set for inner node");
      }
      if (hasPrefix(inner.prefix, prefix)) {
        throw new Error(`Inner node has leaf prefix`);
      }
      if (inner.prefix.length < (spec.minPrefixLength || 0)) {
        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);
      }
      const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;
      if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {
        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);
      }
    }
    exports2.ensureInner = ensureInner;
    function ensurePrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return;
      }
      if (!check) {
        throw new Error(`Target bytes missing`);
      }
      ensureBytesEqual(prefix, check.slice(0, prefix.length));
    }
    function ensureBytesEqual(a, b) {
      if (a.length !== b.length) {
        throw new Error(`Different lengths ${a.length} vs ${b.length}`);
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);
        }
      }
    }
    exports2.ensureBytesEqual = ensureBytesEqual;
    function bytesEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports2.bytesEqual = bytesEqual;
    function hasPrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return false;
      }
      if (!check) {
        return false;
      }
      if (check.length <= prefix.length) {
        return false;
      }
      for (let i = 0; i < prefix.length; i++) {
        if (check[i] !== prefix[i]) {
          return false;
        }
      }
      throw true;
    }
    function ensureBytesBefore(first, last) {
      if (!bytesBefore(first, last)) {
        throw new Error("first is after last");
      }
    }
    exports2.ensureBytesBefore = ensureBytesBefore;
    function bytesBefore(first, last) {
      const min = first.length < last.length ? first.length : last.length;
      for (let i = 0; i < min; i++) {
        if (first[i] < last[i]) {
          return true;
        }
        if (first[i] > last[i]) {
          return false;
        }
      }
      return first.length < last.length;
    }
    exports2.bytesBefore = bytesBefore;
  }
});

// node_modules/@confio/ics23/build/proofs.js
var require_proofs = __commonJS({
  "node_modules/@confio/ics23/build/proofs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureLeftNeighbor = exports2.ensureSpec = exports2.calculateExistenceRoot = exports2.verifyNonExistence = exports2.verifyExistence = exports2.smtSpec = exports2.tendermintSpec = exports2.iavlSpec = void 0;
    var codecimpl_1 = require_codecimpl();
    var ops_1 = require_ops();
    var specs_1 = require_specs();
    exports2.iavlSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 4,
        maxPrefixLength: 12,
        childSize: 33,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports2.tendermintSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 1,
        maxPrefixLength: 1,
        childSize: 32,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports2.smtSpec = {
      leafSpec: {
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,
        prefix: Uint8Array.from([0])
      },
      innerSpec: {
        childOrder: [0, 1],
        childSize: 32,
        minPrefixLength: 1,
        maxPrefixLength: 1,
        emptyChild: new Uint8Array(32),
        hash: codecimpl_1.ics23.HashOp.SHA256
      },
      maxDepth: 256
    };
    function verifyExistence(proof, spec, root, key, value) {
      ensureSpec(proof, spec);
      const calc = calculateExistenceRoot(proof);
      (0, specs_1.ensureBytesEqual)(calc, root);
      (0, specs_1.ensureBytesEqual)(key, proof.key);
      (0, specs_1.ensureBytesEqual)(value, proof.value);
    }
    exports2.verifyExistence = verifyExistence;
    function verifyNonExistence(proof, spec, root, key) {
      let leftKey;
      let rightKey;
      if (proof.left) {
        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);
        leftKey = proof.left.key;
      }
      if (proof.right) {
        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);
        rightKey = proof.right.key;
      }
      if (!leftKey && !rightKey) {
        throw new Error("neither left nor right proof defined");
      }
      if (leftKey) {
        (0, specs_1.ensureBytesBefore)(leftKey, key);
      }
      if (rightKey) {
        (0, specs_1.ensureBytesBefore)(key, rightKey);
      }
      if (!spec.innerSpec) {
        throw new Error("no inner spec");
      }
      if (!leftKey) {
        ensureLeftMost(spec.innerSpec, proof.right.path);
      } else if (!rightKey) {
        ensureRightMost(spec.innerSpec, proof.left.path);
      } else {
        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);
      }
      return;
    }
    exports2.verifyNonExistence = verifyNonExistence;
    function calculateExistenceRoot(proof) {
      if (!proof.key || !proof.value) {
        throw new Error("Existence proof needs key and value set");
      }
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      const path = proof.path || [];
      let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);
      for (const inner of path) {
        res = (0, ops_1.applyInner)(inner, res);
      }
      return res;
    }
    exports2.calculateExistenceRoot = calculateExistenceRoot;
    function ensureSpec(proof, spec) {
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      if (!spec.leafSpec) {
        throw new Error("Spec must include leafSpec");
      }
      if (!spec.innerSpec) {
        throw new Error("Spec must include innerSpec");
      }
      (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);
      const path = proof.path || [];
      if (spec.minDepth && path.length < spec.minDepth) {
        throw new Error(`Too few inner nodes ${path.length}`);
      }
      if (spec.maxDepth && path.length > spec.maxDepth) {
        throw new Error(`Too many inner nodes ${path.length}`);
      }
      for (const inner of path) {
        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);
      }
    }
    exports2.ensureSpec = ensureSpec;
    function ensureLeftMost(spec, path) {
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureRightMost(spec, path) {
      const len = spec.childOrder.length - 1;
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureLeftNeighbor(spec, left, right) {
      const mutleft = [...left];
      const mutright = [...right];
      let topleft = mutleft.pop();
      let topright = mutright.pop();
      while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {
        topleft = mutleft.pop();
        topright = mutright.pop();
      }
      if (!isLeftStep(spec, topleft, topright)) {
        throw new Error(`Not left neightbor at first divergent step`);
      }
      ensureRightMost(spec, mutleft);
      ensureLeftMost(spec, mutright);
    }
    exports2.ensureLeftNeighbor = ensureLeftNeighbor;
    function isLeftStep(spec, left, right) {
      const leftidx = orderFromPadding(spec, left);
      const rightidx = orderFromPadding(spec, right);
      return rightidx === leftidx + 1;
    }
    function orderFromPadding(spec, inner) {
      for (let branch = 0; branch < spec.childOrder.length; branch++) {
        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);
        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {
          return branch;
        }
      }
      throw new Error(`Cannot find any valid spacing for this node`);
    }
    function hasPadding(op, minPrefix, maxPrefix, suffix) {
      if ((op.prefix || []).length < minPrefix) {
        return false;
      }
      if ((op.prefix || []).length > maxPrefix) {
        return false;
      }
      return (op.suffix || []).length === suffix;
    }
    function getPadding(spec, branch) {
      const idx = getPosition(spec.childOrder, branch);
      const prefix = idx * spec.childSize;
      const minPrefix = prefix + spec.minPrefixLength;
      const maxPrefix = prefix + spec.maxPrefixLength;
      const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;
      return { minPrefix, maxPrefix, suffix };
    }
    function getPosition(order, branch) {
      if (branch < 0 || branch >= order.length) {
        throw new Error(`Invalid branch: ${branch}`);
      }
      return order.findIndex((val) => val === branch);
    }
  }
});

// node_modules/@confio/ics23/build/ics23.js
var require_ics23 = __commonJS({
  "node_modules/@confio/ics23/build/ics23.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.batchVerifyNonMembership = exports2.batchVerifyMembership = exports2.verifyNonMembership = exports2.verifyMembership = void 0;
    var compress_1 = require_compress();
    var proofs_1 = require_proofs();
    var specs_1 = require_specs();
    function verifyMembership(proof, spec, root, key, value) {
      const norm = (0, compress_1.decompress)(proof);
      const exist = getExistForKey(norm, key);
      if (!exist) {
        return false;
      }
      try {
        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports2.verifyMembership = verifyMembership;
    function verifyNonMembership(proof, spec, root, key) {
      const norm = (0, compress_1.decompress)(proof);
      const nonexist = getNonExistForKey(norm, key);
      if (!nonexist) {
        return false;
      }
      try {
        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports2.verifyNonMembership = verifyNonMembership;
    function batchVerifyMembership(proof, spec, root, items) {
      const norm = (0, compress_1.decompress)(proof);
      for (const [key, value] of items.entries()) {
        if (!verifyMembership(norm, spec, root, key, value)) {
          return false;
        }
      }
      return true;
    }
    exports2.batchVerifyMembership = batchVerifyMembership;
    function batchVerifyNonMembership(proof, spec, root, keys) {
      const norm = (0, compress_1.decompress)(proof);
      for (const key of keys) {
        if (!verifyNonMembership(norm, spec, root, key)) {
          return false;
        }
      }
      return true;
    }
    exports2.batchVerifyNonMembership = batchVerifyNonMembership;
    function getExistForKey(proof, key) {
      const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);
      if (match(proof.exist)) {
        return proof.exist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.exist || null).find(match);
      }
      return void 0;
    }
    function getNonExistForKey(proof, key) {
      const match = (p) => {
        return !!p && (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) && (!p.right || (0, specs_1.bytesBefore)(key, p.right.key));
      };
      if (match(proof.nonexist)) {
        return proof.nonexist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.nonexist || null).find(match);
      }
      return void 0;
    }
  }
});

// node_modules/@confio/ics23/build/index.js
var require_build = __commonJS({
  "node_modules/@confio/ics23/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyNonExistence = exports2.verifyExistence = exports2.tendermintSpec = exports2.iavlSpec = exports2.calculateExistenceRoot = exports2.verifyNonMembership = exports2.verifyMembership = exports2.ics23 = void 0;
    var codecimpl_1 = require_codecimpl();
    Object.defineProperty(exports2, "ics23", { enumerable: true, get: function() {
      return codecimpl_1.ics23;
    } });
    var ics23_1 = require_ics23();
    Object.defineProperty(exports2, "verifyMembership", { enumerable: true, get: function() {
      return ics23_1.verifyMembership;
    } });
    Object.defineProperty(exports2, "verifyNonMembership", { enumerable: true, get: function() {
      return ics23_1.verifyNonMembership;
    } });
    var proofs_1 = require_proofs();
    Object.defineProperty(exports2, "calculateExistenceRoot", { enumerable: true, get: function() {
      return proofs_1.calculateExistenceRoot;
    } });
    Object.defineProperty(exports2, "iavlSpec", { enumerable: true, get: function() {
      return proofs_1.iavlSpec;
    } });
    Object.defineProperty(exports2, "tendermintSpec", { enumerable: true, get: function() {
      return proofs_1.tendermintSpec;
    } });
    Object.defineProperty(exports2, "verifyExistence", { enumerable: true, get: function() {
      return proofs_1.verifyExistence;
    } });
    Object.defineProperty(exports2, "verifyNonExistence", { enumerable: true, get: function() {
      return proofs_1.verifyNonExistence;
    } });
  }
});

// node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/symbol-observable/lib/ponyfill.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/symbol-observable/ponyfill.js
var require_ponyfill2 = __commonJS({
  "node_modules/symbol-observable/ponyfill.js"(exports2, module2) {
    module2.exports = require_ponyfill();
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/globalthis/implementation.browser.js"(exports2, module2) {
    "use strict";
    if (typeof self !== "undefined") {
      module2.exports = self;
    } else if (typeof window !== "undefined") {
      module2.exports = window;
    } else {
      module2.exports = Function("return this")();
    }
  }
});

// node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/globalthis/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation_browser();
    module2.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "node_modules/globalthis/shim.js"(exports2, module2) {
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill();
    module2.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "node_modules/globalthis/index.js"(exports2, module2) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = getGlobal;
  }
});

// node_modules/xstream/index.js
var require_xstream = __commonJS({
  "node_modules/xstream/index.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NO_IL = exports2.NO = exports2.MemoryStream = exports2.Stream = void 0;
    var ponyfill_1 = require_ponyfill2();
    var globalthis_1 = require_globalthis();
    var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
    var NO = {};
    exports2.NO = NO;
    function noop() {
    }
    function cp(a) {
      var l = a.length;
      var b = Array(l);
      for (var i = 0; i < l; ++i)
        b[i] = a[i];
      return b;
    }
    function and(f1, f2) {
      return function andFn(t) {
        return f1(t) && f2(t);
      };
    }
    function _try(c, t, u) {
      try {
        return c.f(t);
      } catch (e) {
        u._e(e);
        return NO;
      }
    }
    var NO_IL = {
      _n: noop,
      _e: noop,
      _c: noop
    };
    exports2.NO_IL = NO_IL;
    function internalizeProducer(producer) {
      producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
      };
      producer._stop = producer.stop;
    }
    var StreamSub = (
      /** @class */
      function() {
        function StreamSub2(_stream, _listener) {
          this._stream = _stream;
          this._listener = _listener;
        }
        StreamSub2.prototype.unsubscribe = function() {
          this._stream._remove(this._listener);
        };
        return StreamSub2;
      }()
    );
    var Observer = (
      /** @class */
      function() {
        function Observer2(_listener) {
          this._listener = _listener;
        }
        Observer2.prototype.next = function(value) {
          this._listener._n(value);
        };
        Observer2.prototype.error = function(err) {
          this._listener._e(err);
        };
        Observer2.prototype.complete = function() {
          this._listener._c();
        };
        return Observer2;
      }()
    );
    var FromObservable = (
      /** @class */
      function() {
        function FromObservable2(observable) {
          this.type = "fromObservable";
          this.ins = observable;
          this.active = false;
        }
        FromObservable2.prototype._start = function(out) {
          this.out = out;
          this.active = true;
          this._sub = this.ins.subscribe(new Observer(out));
          if (!this.active)
            this._sub.unsubscribe();
        };
        FromObservable2.prototype._stop = function() {
          if (this._sub)
            this._sub.unsubscribe();
          this.active = false;
        };
        return FromObservable2;
      }()
    );
    var Merge = (
      /** @class */
      function() {
        function Merge2(insArr) {
          this.type = "merge";
          this.insArr = insArr;
          this.out = NO;
          this.ac = 0;
        }
        Merge2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var L = s.length;
          this.ac = L;
          for (var i = 0; i < L; i++)
            s[i]._add(this);
        };
        Merge2.prototype._stop = function() {
          var s = this.insArr;
          var L = s.length;
          for (var i = 0; i < L; i++)
            s[i]._remove(this);
          this.out = NO;
        };
        Merge2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        Merge2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Merge2.prototype._c = function() {
          if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
              return;
            u._c();
          }
        };
        return Merge2;
      }()
    );
    var CombineListener = (
      /** @class */
      function() {
        function CombineListener2(i, out, p) {
          this.i = i;
          this.out = out;
          this.p = p;
          p.ils.push(this);
        }
        CombineListener2.prototype._n = function(t) {
          var p = this.p, out = this.out;
          if (out === NO)
            return;
          if (p.up(t, this.i)) {
            var b = cp(p.vals);
            out._n(b);
          }
        };
        CombineListener2.prototype._e = function(err) {
          var out = this.out;
          if (out === NO)
            return;
          out._e(err);
        };
        CombineListener2.prototype._c = function() {
          var p = this.p;
          if (p.out === NO)
            return;
          if (--p.Nc === 0)
            p.out._c();
        };
        return CombineListener2;
      }()
    );
    var Combine = (
      /** @class */
      function() {
        function Combine2(insArr) {
          this.type = "combine";
          this.insArr = insArr;
          this.out = NO;
          this.ils = [];
          this.Nc = this.Nn = 0;
          this.vals = [];
        }
        Combine2.prototype.up = function(t, i) {
          var v = this.vals[i];
          var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
          this.vals[i] = t;
          return Nn === 0;
        };
        Combine2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var n = this.Nc = this.Nn = s.length;
          var vals = this.vals = new Array(n);
          if (n === 0) {
            out._n([]);
            out._c();
          } else {
            for (var i = 0; i < n; i++) {
              vals[i] = NO;
              s[i]._add(new CombineListener(i, out, this));
            }
          }
        };
        Combine2.prototype._stop = function() {
          var s = this.insArr;
          var n = s.length;
          var ils = this.ils;
          for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
          this.out = NO;
          this.ils = [];
          this.vals = [];
        };
        return Combine2;
      }()
    );
    var FromArray = (
      /** @class */
      function() {
        function FromArray2(a) {
          this.type = "fromArray";
          this.a = a;
        }
        FromArray2.prototype._start = function(out) {
          var a = this.a;
          for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
          out._c();
        };
        FromArray2.prototype._stop = function() {
        };
        return FromArray2;
      }()
    );
    var FromPromise = (
      /** @class */
      function() {
        function FromPromise2(p) {
          this.type = "fromPromise";
          this.on = false;
          this.p = p;
        }
        FromPromise2.prototype._start = function(out) {
          var prod = this;
          this.on = true;
          this.p.then(function(v) {
            if (prod.on) {
              out._n(v);
              out._c();
            }
          }, function(e) {
            out._e(e);
          }).then(noop, function(err) {
            setTimeout(function() {
              throw err;
            });
          });
        };
        FromPromise2.prototype._stop = function() {
          this.on = false;
        };
        return FromPromise2;
      }()
    );
    var Periodic = (
      /** @class */
      function() {
        function Periodic2(period) {
          this.type = "periodic";
          this.period = period;
          this.intervalID = -1;
          this.i = 0;
        }
        Periodic2.prototype._start = function(out) {
          var self2 = this;
          function intervalHandler() {
            out._n(self2.i++);
          }
          this.intervalID = setInterval(intervalHandler, this.period);
        };
        Periodic2.prototype._stop = function() {
          if (this.intervalID !== -1)
            clearInterval(this.intervalID);
          this.intervalID = -1;
          this.i = 0;
        };
        return Periodic2;
      }()
    );
    var Debug = (
      /** @class */
      function() {
        function Debug2(ins, arg) {
          this.type = "debug";
          this.ins = ins;
          this.out = NO;
          this.s = noop;
          this.l = "";
          if (typeof arg === "string")
            this.l = arg;
          else if (typeof arg === "function")
            this.s = arg;
        }
        Debug2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Debug2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Debug2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var s = this.s, l = this.l;
          if (s !== noop) {
            try {
              s(t);
            } catch (e) {
              u._e(e);
            }
          } else if (l)
            console.log(l + ":", t);
          else
            console.log(t);
          u._n(t);
        };
        Debug2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Debug2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Debug2;
      }()
    );
    var Drop = (
      /** @class */
      function() {
        function Drop2(max, ins) {
          this.type = "drop";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.dropped = 0;
        }
        Drop2.prototype._start = function(out) {
          this.out = out;
          this.dropped = 0;
          this.ins._add(this);
        };
        Drop2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Drop2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          if (this.dropped++ >= this.max)
            u._n(t);
        };
        Drop2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Drop2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Drop2;
      }()
    );
    var EndWhenListener = (
      /** @class */
      function() {
        function EndWhenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        EndWhenListener2.prototype._n = function() {
          this.op.end();
        };
        EndWhenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        EndWhenListener2.prototype._c = function() {
          this.op.end();
        };
        return EndWhenListener2;
      }()
    );
    var EndWhen = (
      /** @class */
      function() {
        function EndWhen2(o, ins) {
          this.type = "endWhen";
          this.ins = ins;
          this.out = NO;
          this.o = o;
          this.oil = NO_IL;
        }
        EndWhen2.prototype._start = function(out) {
          this.out = out;
          this.o._add(this.oil = new EndWhenListener(out, this));
          this.ins._add(this);
        };
        EndWhen2.prototype._stop = function() {
          this.ins._remove(this);
          this.o._remove(this.oil);
          this.out = NO;
          this.oil = NO_IL;
        };
        EndWhen2.prototype.end = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        EndWhen2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        EndWhen2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        EndWhen2.prototype._c = function() {
          this.end();
        };
        return EndWhen2;
      }()
    );
    var Filter = (
      /** @class */
      function() {
        function Filter2(passes, ins) {
          this.type = "filter";
          this.ins = ins;
          this.out = NO;
          this.f = passes;
        }
        Filter2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Filter2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Filter2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO || !r)
            return;
          u._n(t);
        };
        Filter2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Filter2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Filter2;
      }()
    );
    var FlattenListener = (
      /** @class */
      function() {
        function FlattenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        FlattenListener2.prototype._n = function(t) {
          this.out._n(t);
        };
        FlattenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        FlattenListener2.prototype._c = function() {
          this.op.inner = NO;
          this.op.less();
        };
        return FlattenListener2;
      }()
    );
    var Flatten = (
      /** @class */
      function() {
        function Flatten2(ins) {
          this.type = "flatten";
          this.ins = ins;
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        }
        Flatten2.prototype._start = function(out) {
          this.out = out;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
          this.ins._add(this);
        };
        Flatten2.prototype._stop = function() {
          this.ins._remove(this);
          if (this.inner !== NO)
            this.inner._remove(this.il);
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        };
        Flatten2.prototype.less = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (!this.open && this.inner === NO)
            u._c();
        };
        Flatten2.prototype._n = function(s) {
          var u = this.out;
          if (u === NO)
            return;
          var _a = this, inner = _a.inner, il = _a.il;
          if (inner !== NO && il !== NO_IL)
            inner._remove(il);
          (this.inner = s)._add(this.il = new FlattenListener(u, this));
        };
        Flatten2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Flatten2.prototype._c = function() {
          this.open = false;
          this.less();
        };
        return Flatten2;
      }()
    );
    var Fold = (
      /** @class */
      function() {
        function Fold2(f, seed, ins) {
          var _this = this;
          this.type = "fold";
          this.ins = ins;
          this.out = NO;
          this.f = function(t) {
            return f(_this.acc, t);
          };
          this.acc = this.seed = seed;
        }
        Fold2.prototype._start = function(out) {
          this.out = out;
          this.acc = this.seed;
          out._n(this.acc);
          this.ins._add(this);
        };
        Fold2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.acc = this.seed;
        };
        Fold2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(this.acc = r);
        };
        Fold2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Fold2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Fold2;
      }()
    );
    var Last = (
      /** @class */
      function() {
        function Last2(ins) {
          this.type = "last";
          this.ins = ins;
          this.out = NO;
          this.has = false;
          this.val = NO;
        }
        Last2.prototype._start = function(out) {
          this.out = out;
          this.has = false;
          this.ins._add(this);
        };
        Last2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.val = NO;
        };
        Last2.prototype._n = function(t) {
          this.has = true;
          this.val = t;
        };
        Last2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Last2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (this.has) {
            u._n(this.val);
            u._c();
          } else
            u._e(new Error("last() failed because input stream completed"));
        };
        return Last2;
      }()
    );
    var MapOp = (
      /** @class */
      function() {
        function MapOp2(project, ins) {
          this.type = "map";
          this.ins = ins;
          this.out = NO;
          this.f = project;
        }
        MapOp2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        MapOp2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        MapOp2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(r);
        };
        MapOp2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        MapOp2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return MapOp2;
      }()
    );
    var Remember = (
      /** @class */
      function() {
        function Remember2(ins) {
          this.type = "remember";
          this.ins = ins;
          this.out = NO;
        }
        Remember2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(out);
        };
        Remember2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return Remember2;
      }()
    );
    var ReplaceError = (
      /** @class */
      function() {
        function ReplaceError2(replacer, ins) {
          this.type = "replaceError";
          this.ins = ins;
          this.out = NO;
          this.f = replacer;
        }
        ReplaceError2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        ReplaceError2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        ReplaceError2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        ReplaceError2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
          } catch (e) {
            u._e(e);
          }
        };
        ReplaceError2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return ReplaceError2;
      }()
    );
    var StartWith = (
      /** @class */
      function() {
        function StartWith2(ins, val) {
          this.type = "startWith";
          this.ins = ins;
          this.out = NO;
          this.val = val;
        }
        StartWith2.prototype._start = function(out) {
          this.out = out;
          this.out._n(this.val);
          this.ins._add(out);
        };
        StartWith2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return StartWith2;
      }()
    );
    var Take = (
      /** @class */
      function() {
        function Take2(max, ins) {
          this.type = "take";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.taken = 0;
        }
        Take2.prototype._start = function(out) {
          this.out = out;
          this.taken = 0;
          if (this.max <= 0)
            out._c();
          else
            this.ins._add(this);
        };
        Take2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Take2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var m = ++this.taken;
          if (m < this.max)
            u._n(t);
          else if (m === this.max) {
            u._n(t);
            u._c();
          }
        };
        Take2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Take2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Take2;
      }()
    );
    var Stream = (
      /** @class */
      function() {
        function Stream2(producer) {
          this._prod = producer || NO;
          this._ils = [];
          this._stopID = NO;
          this._dl = NO;
          this._d = false;
          this._target = null;
          this._err = NO;
        }
        Stream2.prototype._n = function(t) {
          var a = this._ils;
          var L = a.length;
          if (this._d)
            this._dl._n(t);
          if (L == 1)
            a[0]._n(t);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._n(t);
          }
        };
        Stream2.prototype._e = function(err) {
          if (this._err !== NO)
            return;
          this._err = err;
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._e(err);
          if (L == 1)
            a[0]._e(err);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._e(err);
          }
          if (!this._d && L == 0)
            throw this._err;
        };
        Stream2.prototype._c = function() {
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._c();
          if (L == 1)
            a[0]._c();
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._c();
          }
        };
        Stream2.prototype._x = function() {
          if (this._ils.length === 0)
            return;
          if (this._prod !== NO)
            this._prod._stop();
          this._err = NO;
          this._ils = [];
        };
        Stream2.prototype._stopNow = function() {
          this._prod._stop();
          this._err = NO;
          this._stopID = NO;
        };
        Stream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1)
            return;
          if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        Stream2.prototype._remove = function(il) {
          var _this = this;
          var ta = this._target;
          if (ta)
            return ta._remove(il);
          var a = this._ils;
          var i = a.indexOf(il);
          if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
              this._err = NO;
              this._stopID = setTimeout(function() {
                return _this._stopNow();
              });
            } else if (a.length === 1) {
              this._pruneCycles();
            }
          }
        };
        Stream2.prototype._pruneCycles = function() {
          if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
        };
        Stream2.prototype._hasNoSinks = function(x, trace) {
          if (trace.indexOf(x) !== -1)
            return true;
          else if (x.out === this)
            return true;
          else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
          else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
              if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                return false;
            return true;
          } else
            return false;
        };
        Stream2.prototype.ctor = function() {
          return this instanceof MemoryStream ? MemoryStream : Stream2;
        };
        Stream2.prototype.addListener = function(listener) {
          listener._n = listener.next || noop;
          listener._e = listener.error || noop;
          listener._c = listener.complete || noop;
          this._add(listener);
        };
        Stream2.prototype.removeListener = function(listener) {
          this._remove(listener);
        };
        Stream2.prototype.subscribe = function(listener) {
          this.addListener(listener);
          return new StreamSub(this, listener);
        };
        Stream2.prototype[$$observable] = function() {
          return this;
        };
        Stream2.create = function(producer) {
          if (producer) {
            if (typeof producer.start !== "function" || typeof producer.stop !== "function")
              throw new Error("producer requires both start and stop functions");
            internalizeProducer(producer);
          }
          return new Stream2(producer);
        };
        Stream2.createWithMemory = function(producer) {
          if (producer)
            internalizeProducer(producer);
          return new MemoryStream(producer);
        };
        Stream2.never = function() {
          return new Stream2({ _start: noop, _stop: noop });
        };
        Stream2.empty = function() {
          return new Stream2({
            _start: function(il) {
              il._c();
            },
            _stop: noop
          });
        };
        Stream2.throw = function(error) {
          return new Stream2({
            _start: function(il) {
              il._e(error);
            },
            _stop: noop
          });
        };
        Stream2.from = function(input) {
          if (typeof input[$$observable] === "function")
            return Stream2.fromObservable(input);
          else if (typeof input.then === "function")
            return Stream2.fromPromise(input);
          else if (Array.isArray(input))
            return Stream2.fromArray(input);
          throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
        };
        Stream2.of = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          return Stream2.fromArray(items);
        };
        Stream2.fromArray = function(array) {
          return new Stream2(new FromArray(array));
        };
        Stream2.fromPromise = function(promise) {
          return new Stream2(new FromPromise(promise));
        };
        Stream2.fromObservable = function(obs) {
          if (obs.endWhen !== void 0)
            return obs;
          var o = typeof obs[$$observable] === "function" ? obs[$$observable]() : obs;
          return new Stream2(new FromObservable(o));
        };
        Stream2.periodic = function(period) {
          return new Stream2(new Periodic(period));
        };
        Stream2.prototype._map = function(project) {
          return new (this.ctor())(new MapOp(project, this));
        };
        Stream2.prototype.map = function(project) {
          return this._map(project);
        };
        Stream2.prototype.mapTo = function(projectedValue) {
          var s = this.map(function() {
            return projectedValue;
          });
          var op = s._prod;
          op.type = "mapTo";
          return s;
        };
        Stream2.prototype.filter = function(passes) {
          var p = this._prod;
          if (p instanceof Filter)
            return new Stream2(new Filter(and(p.f, passes), p.ins));
          return new Stream2(new Filter(passes, this));
        };
        Stream2.prototype.take = function(amount) {
          return new (this.ctor())(new Take(amount, this));
        };
        Stream2.prototype.drop = function(amount) {
          return new Stream2(new Drop(amount, this));
        };
        Stream2.prototype.last = function() {
          return new Stream2(new Last(this));
        };
        Stream2.prototype.startWith = function(initial) {
          return new MemoryStream(new StartWith(this, initial));
        };
        Stream2.prototype.endWhen = function(other) {
          return new (this.ctor())(new EndWhen(other, this));
        };
        Stream2.prototype.fold = function(accumulate, seed) {
          return new MemoryStream(new Fold(accumulate, seed, this));
        };
        Stream2.prototype.replaceError = function(replace) {
          return new (this.ctor())(new ReplaceError(replace, this));
        };
        Stream2.prototype.flatten = function() {
          return new Stream2(new Flatten(this));
        };
        Stream2.prototype.compose = function(operator) {
          return operator(this);
        };
        Stream2.prototype.remember = function() {
          return new MemoryStream(new Remember(this));
        };
        Stream2.prototype.debug = function(labelOrSpy) {
          return new (this.ctor())(new Debug(this, labelOrSpy));
        };
        Stream2.prototype.imitate = function(target) {
          if (target instanceof MemoryStream)
            throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
          this._target = target;
          for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
          this._ils = [];
        };
        Stream2.prototype.shamefullySendNext = function(value) {
          this._n(value);
        };
        Stream2.prototype.shamefullySendError = function(error) {
          this._e(error);
        };
        Stream2.prototype.shamefullySendComplete = function() {
          this._c();
        };
        Stream2.prototype.setDebugListener = function(listener) {
          if (!listener) {
            this._d = false;
            this._dl = NO;
          } else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
          }
        };
        Stream2.merge = function merge() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Merge(streams));
        };
        Stream2.combine = function combine() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Combine(streams));
        };
        return Stream2;
      }()
    );
    exports2.Stream = Stream;
    var MemoryStream = (
      /** @class */
      function(_super) {
        __extends(MemoryStream2, _super);
        function MemoryStream2(producer) {
          var _this = _super.call(this, producer) || this;
          _this._has = false;
          return _this;
        }
        MemoryStream2.prototype._n = function(x) {
          this._v = x;
          this._has = true;
          _super.prototype._n.call(this, x);
        };
        MemoryStream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1) {
            if (this._has)
              il._n(this._v);
            return;
          }
          if (this._stopID !== NO) {
            if (this._has)
              il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else if (this._has)
            il._n(this._v);
          else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        MemoryStream2.prototype._stopNow = function() {
          this._has = false;
          _super.prototype._stopNow.call(this);
        };
        MemoryStream2.prototype._x = function() {
          this._has = false;
          _super.prototype._x.call(this);
        };
        MemoryStream2.prototype.map = function(project) {
          return this._map(project);
        };
        MemoryStream2.prototype.mapTo = function(projectedValue) {
          return _super.prototype.mapTo.call(this, projectedValue);
        };
        MemoryStream2.prototype.take = function(amount) {
          return _super.prototype.take.call(this, amount);
        };
        MemoryStream2.prototype.endWhen = function(other) {
          return _super.prototype.endWhen.call(this, other);
        };
        MemoryStream2.prototype.replaceError = function(replace) {
          return _super.prototype.replaceError.call(this, replace);
        };
        MemoryStream2.prototype.remember = function() {
          return this;
        };
        MemoryStream2.prototype.debug = function(labelOrSpy) {
          return _super.prototype.debug.call(this, labelOrSpy);
        };
        return MemoryStream2;
      }(Stream)
    );
    exports2.MemoryStream = MemoryStream;
    var xs = Stream;
    exports2.default = xs;
  }
});

// node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-ws/browser.js"(exports2, module2) {
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module2.exports = ws;
  }
});

export {
  require_minimal2 as require_minimal,
  require_build,
  require_xstream,
  require_browser
};
//# sourceMappingURL=chunk-CEAMBVQN.js.map
