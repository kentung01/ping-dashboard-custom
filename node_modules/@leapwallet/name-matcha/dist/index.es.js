var J = Object.defineProperty;
var M = (s, a, n) => a in s ? J(s, a, { enumerable: !0, configurable: !0, writable: !0, value: n }) : s[a] = n;
var u = (s, a, n) => (M(s, typeof a != "symbol" ? a + "" : a, n), n);
import { CosmWasmClient as Q } from "@cosmjs/cosmwasm-stargate";
import * as X from "js-sha3";
import { toUnicode as Y } from "idna-uts46-hx";
var U = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", T = {};
for (var D = 0; D < U.length; D++) {
  var q = U.charAt(D);
  if (T[q] !== void 0)
    throw new TypeError(q + " is ambiguous");
  T[q] = D;
}
function g(s) {
  var a = s >> 25;
  return (s & 33554431) << 5 ^ -(a >> 0 & 1) & 996825010 ^ -(a >> 1 & 1) & 642813549 ^ -(a >> 2 & 1) & 513874426 ^ -(a >> 3 & 1) & 1027748829 ^ -(a >> 4 & 1) & 705979059;
}
function R(s) {
  for (var a = 1, n = 0; n < s.length; ++n) {
    var e = s.charCodeAt(n);
    if (e < 33 || e > 126)
      return "Invalid prefix (" + s + ")";
    a = g(a) ^ e >> 5;
  }
  for (a = g(a), n = 0; n < s.length; ++n) {
    var r = s.charCodeAt(n);
    a = g(a) ^ r & 31;
  }
  return a;
}
function Z(s, a, n) {
  if (n = n || 90, s.length + 7 + a.length > n)
    throw new TypeError("Exceeds length limit");
  s = s.toLowerCase();
  var e = R(s);
  if (typeof e == "string")
    throw new Error(e);
  for (var r = s + "1", t = 0; t < a.length; ++t) {
    var c = a[t];
    if (c >> 5)
      throw new Error("Non 5-bit word");
    e = g(e) ^ c, r += U.charAt(c);
  }
  for (t = 0; t < 6; ++t)
    e = g(e);
  for (e ^= 1, t = 0; t < 6; ++t) {
    var l = e >> (5 - t) * 5 & 31;
    r += U.charAt(l);
  }
  return r;
}
function P(s, a) {
  if (a = a || 90, s.length < 8)
    return s + " too short";
  if (s.length > a)
    return "Exceeds length limit";
  var n = s.toLowerCase(), e = s.toUpperCase();
  if (s !== n && s !== e)
    return "Mixed-case string " + s;
  s = n;
  var r = s.lastIndexOf("1");
  if (r === -1)
    return "No separator character for " + s;
  if (r === 0)
    return "Missing prefix for " + s;
  var t = s.slice(0, r), c = s.slice(r + 1);
  if (c.length < 6)
    return "Data too short";
  var l = R(t);
  if (typeof l == "string")
    return l;
  for (var w = [], d = 0; d < c.length; ++d) {
    var h = c.charAt(d), m = T[h];
    if (m === void 0)
      return "Unknown character " + h;
    l = g(l) ^ m, !(d + 6 >= c.length) && w.push(m);
  }
  return l !== 1 ? "Invalid checksum for " + s : { prefix: t, words: w };
}
function ee() {
  var s = P.apply(null, arguments);
  if (typeof s == "object")
    return s;
}
function te(s) {
  var a = P.apply(null, arguments);
  if (typeof a == "object")
    return a;
  throw new Error(a);
}
function C(s, a, n, e) {
  for (var r = 0, t = 0, c = (1 << n) - 1, l = [], w = 0; w < s.length; ++w)
    for (r = r << a | s[w], t += a; t >= n; )
      t -= n, l.push(r >> t & c);
  if (e)
    t > 0 && l.push(r << n - t & c);
  else {
    if (t >= a)
      return "Excess padding";
    if (r << n - t & c)
      return "Non-zero padding";
  }
  return l;
}
function re(s) {
  var a = C(s, 8, 5, !0);
  if (Array.isArray(a))
    return a;
}
function se(s) {
  var a = C(s, 8, 5, !0);
  if (Array.isArray(a))
    return a;
  throw new Error(a);
}
function ne(s) {
  var a = C(s, 5, 8, !1);
  if (Array.isArray(a))
    return a;
}
function ae(s) {
  var a = C(s, 5, 8, !1);
  if (Array.isArray(a))
    return a;
  throw new Error(a);
}
var v = {
  decodeUnsafe: ee,
  decode: te,
  encode: Z,
  toWordsUnsafe: re,
  toWords: se,
  fromWordsUnsafe: ne,
  fromWords: ae
}, o = /* @__PURE__ */ ((s) => (s.NETWORK = "network", s.NOT_FOUND = "not-found", s.UNREGISTERED_SERVICE = "unregistered-service", s.DUPLICATE_SERVICE = "duplicate-service", s.INVALID_ADDRESS = "invalid-address", s.UNAVAILABLE_METHOD = "invalid-address", s))(o || {});
class i extends Error {
  constructor(n, e) {
    super(n);
    u(this, "type");
    this.name = "MatchaError", this.type = e;
  }
}
const S = class {
};
let N = S;
u(N, "clients", {}), u(N, "getClient", async (a) => {
  let n = S.clients[a];
  return n === void 0 && (n = await Q.connect(a), S.clients[a] = n), n;
});
class y {
  /**
   * @param network The network to use
   */
  getCosmWasmClient(a) {
    return N.getClient(a);
  }
}
const F = {
  mainnet: "https://rpc.cosmos.directory/osmosis",
  testnet: "https://rpc-test.osmosis.zone"
}, x = "icns";
class ce extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", x);
    u(this, "chain", "osmosis");
    u(this, "contractAddress", {
      mainnet: "osmo1xk0s8xgktn9x5vwcgtjdxqzadg88fgn33p8u9cnpdxwemvxscvast52cdd",
      testnet: "osmo1q2qpencrnnlamwalxt6tac2ytl35z5jejn0v4frnp6jff7gwp37sjcnhu5"
    });
  }
  async resolve(n, e, r) {
    var w, d, h, m;
    const t = await this.getCosmWasmClient(
      ((d = (w = r == null ? void 0 : r.rpcUrls) == null ? void 0 : w[x]) == null ? void 0 : d[e]) ?? F[e]
    ), [c, l] = n.split(".");
    try {
      const f = await (t == null ? void 0 : t.queryContractSmart(
        this.contractAddress[e],
        {
          address: {
            name: c,
            bech32_prefix: l
          }
        }
      ));
      if (!(f != null && f.address) || ((m = (h = r == null ? void 0 : r.allowedTopLevelDomains) == null ? void 0 : h.icns) == null ? void 0 : m.indexOf(l)) === -1)
        throw new i("", o.NOT_FOUND);
      return f.address;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e, r) {
    var l, w;
    const t = await this.getCosmWasmClient(
      ((w = (l = r == null ? void 0 : r.rpcUrls) == null ? void 0 : l[x]) == null ? void 0 : w[e]) ?? F[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: d, words: h } = v.decode(n);
      c.prefix = d, c.words = h;
    } catch {
      throw new i("", o.INVALID_ADDRESS);
    }
    try {
      const d = await (t == null ? void 0 : t.queryContractSmart(
        this.contractAddress[e],
        {
          primary_name: {
            address: n
          }
        }
      ));
      if (!(d != null && d.name))
        throw new i("", o.NOT_FOUND);
      return `${d.name}.${c.prefix}`;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const E = {
  mainnet: "https://rpc.cosmos.directory/juno",
  testnet: "https://rpc.uni.kingnodes.com"
}, O = "ibcDomains";
class oe extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", O);
    u(this, "chain", "juno");
    u(this, "contractAddress", {
      mainnet: "juno1ce7wjfsuk79t2mdvpdjtv8280pcc64yh9mh62qptuvxe64twt4pqa68z2a",
      testnet: "juno19al2ptpxz3xk6q8nl3eyvyslkz8g6nz25w48dfpaepwaxavq3mhqsjjqe5"
    });
  }
  async resolve(n, e, r) {
    var w, d, h, m;
    const t = await this.getCosmWasmClient(
      ((d = (w = r == null ? void 0 : r.rpcUrls) == null ? void 0 : w[O]) == null ? void 0 : d[e]) ?? E[e]
    ), [c, l] = n.split(".");
    try {
      const f = await (t == null ? void 0 : t.queryContractSmart(
        this.contractAddress[e],
        {
          owner_of: {
            token_id: c
          }
        }
      ));
      if (!(f != null && f.owner) || ((m = (h = r == null ? void 0 : r.allowedTopLevelDomains) == null ? void 0 : h.ibcDomains) == null ? void 0 : m.indexOf(l)) === -1)
        throw new i("", o.NOT_FOUND);
      try {
        const { words: j } = v.decode(f.owner);
        return v.encode(l, j);
      } catch {
        throw new i("", o.NOT_FOUND);
      }
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e, r) {
    var w, d;
    const t = await this.getCosmWasmClient(
      ((d = (w = r == null ? void 0 : r.rpcUrls) == null ? void 0 : w[O]) == null ? void 0 : d[e]) ?? E[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: h, words: m } = v.decode(n);
      c.prefix = h, c.words = m;
    } catch {
      throw new i("", o.INVALID_ADDRESS);
    }
    const l = v.encode("juno", c.words);
    try {
      const h = await (t == null ? void 0 : t.queryContractSmart(
        this.contractAddress[e],
        {
          primary_domain: {
            address: l
          }
        }
      ));
      if (!(h != null && h.domain))
        throw new i("", o.NOT_FOUND);
      return `${h.domain}.${c.prefix}`;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const k = {
  mainnet: "https://rpc.cosmos.directory/stargaze",
  testnet: "https://rpc.elgafar-1.stargaze-apis.com"
}, A = "stargazeNames";
class ie extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", A);
    u(this, "chain", "stargaze");
    u(this, "contractAddress", {
      mainnet: "stars1fx74nkqkw2748av8j7ew7r3xt9cgjqduwn8m0ur5lhe49uhlsasszc5fhr",
      testnet: "stars1rp5ttjvd5g0vlpltrkyvq62tcrdz949gjtpah000ynh4n2laz52qarz2z8"
    });
  }
  async resolve(n, e, r) {
    var w, d, h, m;
    const t = await this.getCosmWasmClient(
      ((d = (w = r == null ? void 0 : r.rpcUrls) == null ? void 0 : w[A]) == null ? void 0 : d[e]) ?? k[e]
    ), [c, l] = n.split(".");
    try {
      const f = await t.queryContractSmart(
        this.contractAddress[e],
        {
          associated_address: {
            name: c
          }
        }
      );
      if (!f || ((m = (h = r == null ? void 0 : r.allowedTopLevelDomains) == null ? void 0 : h.stargazeNames) == null ? void 0 : m.indexOf(l)) === -1)
        throw new i("", o.NOT_FOUND);
      try {
        const { words: j } = v.decode(f);
        return v.encode(l, j);
      } catch {
        throw new i("", o.NOT_FOUND);
      }
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e, r) {
    var l, w;
    const t = await this.getCosmWasmClient(
      ((w = (l = r == null ? void 0 : r.rpcUrls) == null ? void 0 : l[A]) == null ? void 0 : w[e]) ?? k[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: d, words: h } = v.decode(n);
      c.prefix = d, c.words = h;
    } catch {
      throw new i("", o.INVALID_ADDRESS);
    }
    try {
      return `${await t.queryContractSmart(
        this.contractAddress[e],
        {
          name: {
            address: n
          }
        }
      )}.${c.prefix}`;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const L = {
  mainnet: "https://rpc.mainnet.archway.io",
  testnet: "https://rpc.constantine.archway.tech"
}, _ = "archIds";
class de extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", _);
    u(this, "chain", "archway");
    u(this, "contractAddress", {
      mainnet: "archway1275jwjpktae4y4y0cdq274a2m0jnpekhttnfuljm6n59wnpyd62qppqxq0",
      testnet: "archway1lr8rstt40s697hqpedv2nvt27f4cuccqwvly9gnvuszxmcevrlns60xw4r"
    });
  }
  // reference: https://gist.github.com/drewstaylor/088af645dd36c013c02a2b4d05110479#file-archid-resolve-address-js
  async resolve(n, e, r) {
    var l, w, d, h;
    const t = await this.getCosmWasmClient(
      ((w = (l = r == null ? void 0 : r.rpcUrls) == null ? void 0 : l[_]) == null ? void 0 : w[e]) ?? L[e]
    ), [, c] = n.split(".");
    try {
      const m = await (t == null ? void 0 : t.queryContractSmart(
        this.contractAddress[e],
        {
          resolve_record: {
            name: n
          }
        }
      ));
      if (!(m != null && m.address) || ((h = (d = r == null ? void 0 : r.allowedTopLevelDomains) == null ? void 0 : d.archIds) == null ? void 0 : h.indexOf(c)) === -1)
        throw new i("", o.NOT_FOUND);
      return m.address;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  // reference: https://gist.github.com/drewstaylor/088af645dd36c013c02a2b4d05110479#file-archid-check-domains-resolve-to-address-js
  async lookup(n, e, r) {
    var l, w, d;
    const t = await this.getCosmWasmClient(
      ((w = (l = r == null ? void 0 : r.rpcUrls) == null ? void 0 : l[_]) == null ? void 0 : w[e]) ?? L[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: h, words: m } = v.decode(n);
      c.prefix = h, c.words = m;
    } catch {
      throw new i("", o.INVALID_ADDRESS);
    }
    try {
      const h = await (t == null ? void 0 : t.queryContractSmart(
        this.contractAddress[e],
        {
          resolve_address: {
            address: n
          }
        }
      ));
      if (!(h != null && h.names) || !((d = h == null ? void 0 : h.names) != null && d.length))
        throw new i("", o.NOT_FOUND);
      return h.names.join(", ");
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const { keccak_256: W } = X, he = (s) => s && Y(s, { useStd3ASCII: !0 }), le = (s) => {
  if (!(s.startsWith("[") && s.endsWith("]")))
    throw Error(
      "Expected encoded labelhash to start and end with square brackets"
    );
  if (s.length !== 66)
    throw Error("Expected encoded labelhash to have a length of 66");
  return `${s.slice(1, -1)}`;
}, we = (s) => s.startsWith("[") && s.endsWith("]") && s.length === 66, me = (s) => {
  let a = "";
  for (let n = 0; n < 32; n++)
    a += "00";
  if (s) {
    const n = s.split(".");
    for (let e = n.length - 1; e >= 0; e--) {
      let r;
      if (we(n[e]))
        r = le(n[e]);
      else {
        const t = he(n[e]);
        r = W(t);
      }
      a = W(Buffer.from(a + r, "hex"));
    }
  }
  return "0x" + a;
};
function ue(s) {
  if (!s)
    return [];
  const a = me(s);
  return Array.from(Buffer.from(a.slice(2), "hex"));
}
const p = {
  inj: {
    mainnet: "https://tm.injective.network",
    testnet: "https://testnet.tm.injective.dev"
  },
  sei: {
    mainnet: "https://rpc.wallet.pacific-1.sei.io",
    testnet: "https://sei-testnet-rpc.polkachu.com"
  }
}, B = "spaceIds";
class fe extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", B);
    u(this, "chain", ["injective", "sei"]);
    u(this, "contractAddress", {
      inj: {
        mainnet: "inj1x9m0hceug9qylcyrrtwqtytslv2jrph433thgu",
        testnet: "inj1ppneyx6qfnye26k9mwnf3ngyelvqng67f5v948"
      },
      sei: {
        mainnet: "sei1qujw7gxacyk08fpg0lsf377f727ldq8f9cmjlrxt6awdkag9ypjsdnkh98",
        testnet: "sei1a59k7mc9hsvtaeu532etl2geqmqdyufjncjkg0h3lxsu5u2rpensanaxwf"
      }
    });
  }
  async resolve(n, e, r) {
    var t, c, l;
    try {
      const [, w] = n.split("."), d = (t = p == null ? void 0 : p[w]) == null ? void 0 : t[e], h = this.contractAddress[w][e];
      if (d && h) {
        const m = await this.getCosmWasmClient(d), f = await (m == null ? void 0 : m.queryContractSmart(h, {
          address: {
            node: ue(n)
          }
        }));
        if (!(f != null && f.address) || ((l = (c = r == null ? void 0 : r.allowedTopLevelDomains) == null ? void 0 : c.spaceIds) == null ? void 0 : l.indexOf(w)) === -1)
          throw new i("", o.NOT_FOUND);
        return f == null ? void 0 : f.address;
      } else
        throw new i("", o.NOT_FOUND);
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    var t;
    const r = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: c, words: l } = v.decode(n);
      r.prefix = c, r.words = l;
    } catch {
      throw new i("", o.INVALID_ADDRESS);
    }
    try {
      const c = (t = p == null ? void 0 : p[r.prefix]) == null ? void 0 : t[e], l = this.contractAddress[r.prefix][e];
      if (c && l) {
        const w = await this.getCosmWasmClient(c), d = await (w == null ? void 0 : w.queryContractSmart(l, {
          name: {
            address: n.toLowerCase()
          }
        }));
        if (!(d != null && d.name))
          throw new i("", o.NOT_FOUND);
        return d.name.endsWith(r.prefix) ? d.name : d.name + r.prefix;
      } else
        throw new i("", o.NOT_FOUND);
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const G = "sns", z = {
  mainnet: "https://injective-rpc.publicnode.com:443",
  testnet: "https://testnet.sentry.tm.injective.network:443"
}, ve = (s) => s.endsWith(".sol") ? s.slice(0, -4) : s;
class ye extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", G);
    u(this, "chain", "injective");
    u(this, "contractAddress", {
      mainnet: "inj1v7chmgm7vmuwldjt80utmw9c95jkrch979ps8z",
      testnet: "inj1q79ujqyh72p43mhr2ldaly3x6d50rzp3354at3"
    });
  }
  async resolve(n, e) {
    const r = await this.getCosmWasmClient(z[e]);
    try {
      const t = await r.queryContractSmart(
        this.contractAddress[e],
        {
          resolve: {
            domain_name: ve(n)
          }
        }
      );
      if (!t)
        throw new i("", o.NOT_FOUND);
      return t;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    var t, c;
    const r = await this.getCosmWasmClient(z[e]);
    try {
      const l = v.decode(n), w = v.fromWords(l.words), d = [...new Array(12).fill(0), ...w], h = await r.queryContractSmart(
        this.contractAddress[e],
        {
          get_domains_for_owner: {
            owner_chain: 19,
            owner_address: d,
            max_len: 1,
            domain_offset: void 0
          }
        }
      );
      if (!h)
        throw new i("", o.NOT_FOUND);
      const m = (c = (t = h == null ? void 0 : h.domains) == null ? void 0 : t.pop) == null ? void 0 : c.call(t);
      if (!m)
        throw new i("", o.NOT_FOUND);
      return m + ".sol";
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const b = "bdd", $ = {
  mainnet: "https://full-node.mainnet-1.coreum.dev:26657",
  testnet: "https://full-node.testnet-1.coreum.dev:26657"
};
class pe extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", b);
    u(this, "chain", "coreum");
    u(this, "contractAddress", {
      mainnet: "core1z22n0xy004sxm5w9fms48exwpl3vwqxd890nt8ve0kwjj048tgqstlqf6f",
      testnet: "testcore1uwe9yemth6gr58tm56sx3u37t0c5rhmk963fjt480y4nz3cfxers9fn2kh"
    });
  }
  async resolve(n, e) {
    const r = await this.getCosmWasmClient($[e]);
    try {
      const t = await r.queryContractSmart(
        this.contractAddress[e],
        {
          resolve: {
            name: n
          }
        }
      );
      if (!t)
        throw new i("", o.NOT_FOUND);
      return t;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e, r) {
    var d, h;
    const t = await this.getCosmWasmClient(
      ((h = (d = r == null ? void 0 : r.rpcUrls) == null ? void 0 : d[b]) == null ? void 0 : h[e]) ?? $[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: m, words: f } = v.decode(n);
      c.prefix = m, c.words = f;
    } catch {
      throw new i("", o.INVALID_ADDRESS);
    }
    const l = e === "mainnet" ? "core" : "testcore", w = v.encode(l, c.words);
    try {
      const m = await (t == null ? void 0 : t.queryContractSmart(
        this.contractAddress[e],
        {
          primary: {
            address: w
          }
        }
      ));
      if (!m)
        throw new i("", o.NOT_FOUND);
      return m;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const H = "nibId", ge = {
  mainnet: "https://rpc.nibiru.fi:443",
  testnet: "https://rpc.testnet-2.nibiru.fi:443"
}, Ne = (s) => s.endsWith(".nibi") ? s.slice(0, -5) : s;
class De extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", H);
    u(this, "chain", "nibiru");
    u(this, "contractAddress", {
      mainnet: "nibi1q0e70vhrv063eah90mu97sazhywmeegptx642t5px7yfcrf0rrsq2dylen",
      testnet: ""
    });
  }
  async resolve(n, e) {
    const r = await this.getCosmWasmClient(ge[e]);
    if (this.contractAddress[e] == "")
      throw new i("", o.NOT_FOUND);
    try {
      const t = await r.queryContractSmart(
        this.contractAddress[e],
        {
          resolve_record: {
            name: Ne(n)
          }
        }
      );
      if (t == "" || t == null)
        throw new i("", o.NOT_FOUND);
      return t == null ? void 0 : t.address;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    throw new i(`Lookup is unavailable for ${n} on ${e}`, o.UNAVAILABLE_METHOD);
  }
}
const K = "degeNS", V = {
  mainnet: "https://rpc.sei-apis.com:443"
};
class xe extends y {
  constructor() {
    super(...arguments);
    u(this, "serviceID", K);
    u(this, "chain", "sei");
    u(this, "contractAddress", {
      mainnet: "sei10nulnfpdhx2wf7lp9kqa8aez2yxuyxwjyfw9rzlrexd500nhal0sl7mtzm",
      testnet: ""
    });
  }
  async resolve(n, e) {
    if (e === "testnet")
      throw new i(
        `Resolve is unavailable for ${n} on ${e}`,
        o.UNAVAILABLE_METHOD
      );
    const r = await this.getCosmWasmClient(V[e]);
    if (this.contractAddress[e] == "")
      throw new i("", o.NOT_FOUND);
    try {
      const t = await r.queryContractSmart(
        this.contractAddress[e],
        {
          extension: {
            msg: {
              resolves_to: {
                domain_name: n
              }
            }
          }
        }
      );
      if (t == "" || t == null)
        throw new i("", o.NOT_FOUND);
      return t == null ? void 0 : t.address;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    if (e === "testnet")
      throw new i(
        `Lookup is unavailable for ${n} on ${e}`,
        o.UNAVAILABLE_METHOD
      );
    const r = await this.getCosmWasmClient(V[e]);
    if (this.contractAddress[e] == "")
      throw new i("", o.NOT_FOUND);
    try {
      const t = await r.queryContractSmart(
        this.contractAddress[e],
        {
          extension: {
            msg: {
              primary_of: {
                owner: n
              }
            }
          }
        }
      );
      if (t == "" || t == null)
        throw new i("", o.NOT_FOUND);
      return t == null ? void 0 : t.domain_name;
    } catch {
      throw new i("", o.NOT_FOUND);
    }
  }
}
const I = [
  "agoric",
  "akash",
  "arkh",
  "axelar",
  "band",
  "bcna",
  "bitsong",
  "bostrom",
  "cerberus",
  "certik",
  "cheqd",
  "chihuahua",
  "chronic",
  "comdex",
  "cosmos",
  "crc",
  "cre",
  "cro",
  "cudos",
  "darc",
  "decentr",
  "desmos",
  "dig",
  "echelon",
  "emoney",
  "evmos",
  "fetch",
  "firma",
  "galaxy",
  "genesis",
  "gravity",
  "iaa",
  "inj",
  "ixo",
  "juno",
  "kava",
  "ki",
  "like",
  "logos",
  "lum",
  "mantle",
  "mars",
  "meme",
  "micro",
  "mythos",
  "nomic",
  "octa",
  "odin",
  "orai",
  "osmo",
  "panacea",
  "pb",
  "persistence",
  "regen",
  "rizon",
  "secret",
  "sent",
  "sif",
  "somm",
  "star",
  "stars",
  "swth",
  "terra",
  "thor",
  "umee",
  "vdl",
  "kujira",
  "sei",
  "stride",
  "jkl",
  "tori",
  "omniflix",
  "canto",
  "pasg",
  "archway",
  "quasar",
  "neutron",
  "testcore",
  "core",
  "quick",
  "migaloo",
  "kyve",
  "onomy",
  "noble",
  "plq",
  "nolus",
  "c4e",
  "gitopia",
  "nibi",
  "maya",
  "empower",
  "dydx"
], Oe = {
  icns: I,
  ibcDomains: I,
  stargazeNames: I,
  archIds: ["arch"],
  spaceIds: ["inj", "sei"],
  sns: ["sol"],
  nibId: ["nibi"],
  degeNS: ["pp", "sei"],
  bdd: ["core"]
}, Ce = {
  icns: x,
  ibcDomains: O,
  stargazeNames: A,
  archIds: _,
  spaceIds: B,
  sns: G,
  bdd: b,
  nibId: H,
  degeNS: K
}, je = Oe;
class Ae {
  constructor(a) {
    u(this, "services", {});
    this.network = a, this.network = a, this.registerService(new ce()), this.registerService(new oe()), this.registerService(new ie()), this.registerService(new de()), this.registerService(new fe()), this.registerService(new ye()), this.registerService(new pe()), this.registerService(new De()), this.registerService(new xe());
  }
  registerService(a) {
    if (this.services[a.serviceID])
      throw new i(
        "Service already registered",
        o.DUPLICATE_SERVICE
      );
    this.services[a.serviceID] = a;
  }
  getService(a) {
    const n = this.services[a];
    if (!n)
      throw new i(
        "Service not registered",
        o.UNREGISTERED_SERVICE
      );
    return n;
  }
  listServices() {
    return Object.keys(this.services);
  }
  setNetwork(a) {
    this.network = a;
  }
  getNetwork() {
    return this.network;
  }
  async resolve(a, n, e) {
    return this.getService(n).resolve(a, this.network, e);
  }
  async lookup(a, n, e) {
    return this.getService(n).lookup(a, this.network, e);
  }
  async resolveAll(a, n) {
    const e = {};
    return await Promise.all(
      Object.entries(this.services).map(async ([r, t]) => {
        try {
          const c = await t.resolve(a, this.network, n);
          e[r] = c;
        } catch {
          e[r] = null;
        }
      })
    ), e;
  }
  async lookupAll(a, n) {
    const e = {};
    return await Promise.all(
      Object.entries(this.services).map(async ([r, t]) => {
        try {
          const c = await t.lookup(a, this.network, n);
          e[r] = c;
        } catch {
          e[r] = null;
        }
      })
    ), e;
  }
}
const qe = new Ae("mainnet");
export {
  je as allowedTopLevelDomains,
  qe as registry,
  Ce as services
};
//# sourceMappingURL=index.es.js.map
